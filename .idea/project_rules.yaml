# global coding standards

project:
  name: "SaaS Application"
  description: >-
    A scalable and maintainable SaaS application built with modern technologies.

requirements:
  overview:
    purpose: >-
      Define the functional and non-functional requirements for the SaaS application.

functional_requirements:
    user_authentication: >
      The application must support user registration, login, and password recovery.
    data_management: >
      Users should be able to create, read, update, and delete their data.
    notifications: >
      The system should send email notifications for important events (e.g., account creation, password reset).
    reporting: >
      Users should be able to generate reports based on their data.

non_functional_requirements:
  performance: >
    The application should handle up to 1,000 concurrent users with a response time of less than 200ms for API requests.
  scalability: >
    The architecture should support horizontal scaling to accommodate increased user load without significant performance degradation.
  security: >
    Implement industry-standard security practices, including data encryption, secure authentication, and regular security audits.
  maintainability: >
    Code should be modular and well-documented to facilitate easy updates and maintenance.

philosophy:
  - Monorepo: Use a monorepo structure to manage both frontend and backend code in a single repository.
  - Modularization: Separate concerns into distinct modules for better maintainability and scalability.
  - Reusability: Create reusable components and libraries to avoid code duplication.
  - CI/CD: Implement continuous integration and deployment pipelines for automated testing and deployment.
  - Documentation: Maintain comprehensive documentation for both developers and end-users.
  - Testing: Prioritize unit, integration, and end-to-end testing to ensure code quality and reliability.

architecture:
  overview: >
    The architecture is designed to support a scalable and maintainable SaaS application using Cloudflare Workers, Supabase, and a monorepo structure. It emphasizes modularization, reusability, and CI/CD practices.

strategy:
- Monorepo configuration: Includes configuration requirements that are largely divided into two parts: app (front) and infra (backend).
- Code splitting and reuse: Common logic is made into a library and placed in /packages or **/shared, and reused by multiple workers.
- Configuration file management: wrangler.toml/wrangler.jsonc is centralized in the repository root.
- Database migration: Migrations are placed under db/migrations as reversible (up/down) scripts.
- Supabase Functions: Edge functions are separated into supabase/functions, DB access layer into supabase/db.
- Localization and documentation: i18n resources and documentation are managed in a consistent directory structure and verified by CI.
- Low config: Global configuration files and some files are placed directly under the root, with attention to preventing contamination.

Roles of each directory:
- Can utilize public/_headers and _redirects
- Cloudflare Workers-based REST/API server
- Clearly separate handlers and business logic
- Manage Cloudflare resources (Workers triggers, KV, Durable Objects, etc.) with Terraform or CDK
- Centralize management of Supabase Edge Functions and DB schema settings
- Recommend reversible scripts for migrations
- Deploy UI components, utilities, and hooks common to the front and API
- Maximize reusability with a monorepo
- Each migration is based on the principle of "1 file = 1 change x 1 commit"
- Implement up/down in the script to ensure statefulness and reversibility

best practices:
  for deploying SQL migrations:
  - Reversible (up/down) scripts: make it easy to roll back in the event of a failure
  - Single responsibility: 1 migration = 1 change. Table creation and column addition are separate files
  - Versioning: Add sequential numbers to file names (e.g. 001_create_users.sql) to clarify application order
  - Initial data seed: Divide into db/seeds and separate from migration body
  - CI integration: Execute automatic application and validation with pull request to prevent schema inconsistency